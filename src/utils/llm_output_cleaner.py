"""
LLM Output Cleaning Tool
Specifically handles JSON text generated by LLM, extracting valid JSON content
"""
import json
import re
from typing import Dict, Any, Optional

class LLMOutputCleaner:
    """LLM Output Cleaner"""
    
    @staticmethod
    def extract_json_from_text(text: str) -> Optional[Dict[str, Any]]:
        """
        Extract JSON object from arbitrary text

        Args:
            text: Text that may contain JSON

        Returns:
            Parsed JSON dictionary, or None (if extraction fails)
        """
        if not text or not text.strip():
            return None

        cleaned_text = LLMOutputCleaner._clean_code_blocks(text)

        result = LLMOutputCleaner._try_parse_json(cleaned_text)
        if result:
            return result

        result = LLMOutputCleaner._extract_json_with_regex(cleaned_text)
        if result:
            return result

        result = LLMOutputCleaner._fix_common_json_errors(cleaned_text)
        if result:
            return result

        result = LLMOutputCleaner._extract_partial_json(cleaned_text)
        if result:
            return result

        # If all methods fail, log first 500 characters of original text for debugging
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Failed to extract JSON from text. First 500 chars: {text[:500]}")
        return None
    
    @staticmethod
    def _clean_code_blocks(text: str) -> str:
        """Clean code block markers"""
        # Remove markdown code block markers
        text = re.sub(r'```json\s*', '', text, flags=re.IGNORECASE)
        text = re.sub(r'```\s*', '', text)

        # Remove other code block markers
        text = re.sub(r'```[a-zA-Z]*\s*', '', text)

        # Remove JSON labels
        text = re.sub(r'^JSON:\s*', '', text, flags=re.IGNORECASE)
        
        return text.strip()
    
    @staticmethod
    def _try_parse_json(text: str) -> Optional[Dict[str, Any]]:
        """Try parsing JSON directly"""
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            return None
    
    @staticmethod
    def _extract_json_with_regex(text: str) -> Optional[Dict[str, Any]]:
        """Extract JSON object using regular expressions"""
        # Try matching complete JSON objects
        patterns = [
            r'(\{(?:[^{}]|(?R))*\})',
            r'(\{(?:[^{}]|(?:\{[^{}]*\}))*\})',
            r'(\{[^{}]*(?:\{[^{}]*\}[^{}]*)*\})',
            r'(\{.*?\})',
            r'(\[(?:[^\[\]]|(?:\[[^\[\]]*\]))*\])',
            r'(\[.*?\])'
        ]

        for pattern in patterns:
            matches = re.findall(pattern, text, re.DOTALL)
            for match in matches:
                try:
                    # Ensure matched content is not empty
                    if match.strip():
                        return json.loads(match)
                except json.JSONDecodeError:
                    continue

        # If all patterns fail, try more aggressive extraction
        # Find all content between first { and last }
        first_brace = text.find('{')
        last_brace = text.rfind('}')

        if first_brace != -1 and last_brace != -1 and last_brace > first_brace:
            potential_json = text[first_brace:last_brace+1]
            try:
                return json.loads(potential_json)
            except json.JSONDecodeError:
                pass

        return None
    
    @staticmethod
    def _fix_common_json_errors(text: str) -> Optional[Dict[str, Any]]:
        """Fix common JSON errors"""
        # Fix trailing commas
        text = re.sub(r',\s*}', '}', text)
        text = re.sub(r',\s*]', ']', text)

        # Fix single quotes (replace with double quotes, but be careful with string content)
        text = re.sub(r"'([^']*)'", r'"\1"', text)

        # Fix true/false case issues
        text = re.sub(r'\bTrue\b', 'true', text)
        text = re.sub(r'\bFalse\b', 'false', text)
        text = re.sub(r'\bNone\b', 'null', text)

        # Fix Chinese punctuation
        text = text.replace('"', '"')  # Chinese double quote
        text = text.replace('"', '"')  # Chinese double quote
        text = text.replace("'", '"')   # Chinese single quote

        # Fix unquoted key names
        text = re.sub(r'(\w+)\s*:', r'"\1":', text)

        # Fix number format (remove extra quotes)
        text = re.sub(r':\s*"(\d+\.?\d*)"\s*([,}])', r': \1\2', text)

        # Fix newlines and tabs
        text = re.sub(r'\n', '\\n', text)
        text = re.sub(r'\r', '\\r', text)
        text = re.sub(r'\t', '\\t', text)

        # Remove comments (JSON doesn't support comments)
        text = re.sub(r'//.*?\n', '', text)
        text = re.sub(r'/\*.*?\*/', '', text, flags=re.DOTALL)

        # Fix common escape character issues
        text = re.sub(r'\\"', '"', text)  # Remove unnecessary escaping
        text = re.sub(r'\\([^"\\nrtbf])', r'\\\\\1', text)  # Escape characters that need escaping

        # Try parsing fixed JSON
        try:
            return json.loads(text)
        except json.JSONDecodeError:
            return None
    
    @staticmethod
    def _extract_partial_json(text: str) -> Optional[Dict[str, Any]]:
        """Try extracting partial JSON (last resort)"""
        # If text contains JSON structure, try extracting key parts
        if '"reasoning"' in text and '"decomposition"' in text:
            # Try extracting reasoning part
            reasoning_match = re.search(r'"reasoning"\s*:\s*"([^"]*)"', text)
            if reasoning_match:
                reasoning = reasoning_match.group(1)

            # Try extracting decomposition part
            decomposition_match = re.search(r'"decomposition"\s*:\s*(\[.*?\])', text, re.DOTALL)
            if decomposition_match:
                try:
                    decomposition = json.loads(decomposition_match.group(1))
                    return {
                        "reasoning": reasoning if reasoning_match else "",
                        "decomposition": decomposition
                    }
                except:
                    pass

        return None
    
    @staticmethod
    def validate_dag_json(dag_json: Dict[str, Any]) -> bool:
        """
        Validate basic structure of DAG JSON

        Args:
            dag_json: DAG JSON to validate

        Returns:
            True if structure is valid, False otherwise
        """
        if not isinstance(dag_json, dict):
            return False

        # Check basic structure
        if 'nodes' not in dag_json and 'dag' not in dag_json:
            return False

        # Get node data
        dag_data = dag_json.get('dag', dag_json)
        nodes = dag_data.get('nodes', [])

        if not isinstance(nodes, list) or len(nodes) == 0:
            return False

        # Validate node structure
        for node in nodes:
            if not isinstance(node, dict):
                return False
            if 'id' not in node or 'question' not in node:
                return False

        return True

# Global instance for convenience
cleaner = LLMOutputCleaner()

def extract_json_from_llm_output(text: str) -> Optional[Dict[str, Any]]:
    """
    Convenience function to extract JSON from LLM output

    Args:
        text: LLM output text

    Returns:
        Extracted JSON dictionary, or None (if extraction fails)
    """
    return cleaner.extract_json_from_text(text)

def safe_parse_json(text: str, fallback: Optional[Dict[str, Any]] = None) -> Optional[Dict[str, Any]]:
    """
    Safely parse JSON, return fallback on failure

    Args:
        text: JSON text to parse
        fallback: Default value on parse failure

    Returns:
        Parsed JSON dictionary, or fallback
    """
    result = extract_json_from_llm_output(text)
    return result if result is not None else fallback